classdef Plate
    properties (Constant)
        E  = 500.0;
        nu = 0.0020;
        w0 = 1;
        P = 1;
    end
    properties (Dependent)
        h
        l                  % span; computed from S and h
    end
    properties
        k  = 1.0;              % exponential load exponent
        S  = 1.0;              % slenderness S = l/(2h)
        Nx = 600;   Ny = 241;  % grid

    end

    methods
        function obj = Plate(k, slenderness, Nx, Ny)
            obj.k  = k;     obj.S  = slenderness;
            obj.Nx = Nx;    obj.Ny = Ny;
        end

        function L = get.l(obj)
            L = 2*obj.h * obj.S;
        end
        
        function H = get.h(obj)
            H = 
        end

        % ---- solver: returns u,v, grids, and stresses ----
        function [u,v,xv,yv,sigx,sigy,tauxy] = solve_plate_Fourier(obj, Nmode)
            k = obj.k;  l = obj.l;  E = obj.E;  nu = obj.nu;  w0 = obj.w0;
            Nx = obj.Nx; Ny = obj.Ny; h = obj.h;

            G = E/(2*(1+nu));
            I = (2/3)*h^3;
            xv = linspace(0,l,Nx);
            yv = linspace(-h,h,Ny);
            [X,Y] = meshgrid(xv,yv);

            dx = xv(2)-xv(1);
            dy = yv(2)-yv(1);

            [~,iy0] = min(abs(yv));
            ixL = Nx;

            % Fourier of w(x) = w0 * exp(k*x/l)
            a0 = -w0*(exp(k)-1)/k;
            n  = 1:Nmode;
            an = -2*w0*k*(exp(k)-1) ./ (k^2 + (2*pi*n).^2);
            bn = (exp(k)-1)*w0*(4*pi*n) ./ (k^2 + (2*pi*n).^2);

            % n=0 stresses
            sigx  = (a0/(2*I))*((l - X).*X.*Y) + ...
                (a0/(2*I))*((2/3)*Y.^3 - (2/5)*h^2.*Y);
            sigy  = -(a0/(2*I))*((1/3)*Y.^3 - h^2.*Y + (2/3)*h^3);
            tauxy = -(a0/(2*I))*((h^2 - Y.^2).*(X - l/2));

            % modal stresses
            for m = 1:Nmode
                alpha = 2*pi*m/l;
                ah = alpha*h; ch = cosh(ah); sh = sinh(ah);
                S2 = sinh(2*ah);
                Dp = S2 + 2*alpha*h;   % D_+
                Dm = S2 - 2*alpha*h;   % D_-

                cy = cosh(alpha*Y);  sy = sinh(alpha*Y);
                cX = cos(alpha*X);   sX = sin(alpha*X);

                A11 = ( (ah*ch - sh).*cy - alpha*Y.*sy.*sh )/Dp ...
                    - ( (ah*sh - ch).*sy - alpha*Y.*cy.*ch )/Dm;

                A12 = ( (ah*sh + ch).*sy - alpha*Y.*cy.*ch )/Dm ...
                    - ( (ah*ch + sh).*cy - alpha*Y.*sy.*sh )/Dp;

                % a_n (cos family)
                sigx  = sigx  + an(m).*cX .* A11;
                sigy  = sigy  + an(m).*cX .* A12;
                tauxy = tauxy + an(m).*sX .* ...
                    ( (ah*ch).*sy - alpha*Y.*cy.*sh )/Dp ...
                              - an(m).*sX .* ...
                              ( (ah*sh).*cy - alpha*Y.*sy.*ch )/Dm;

                % b_n (sin family)
                sigx  = sigx  + bn(m).*sX .* A11;
                sigy  = sigy  + bn(m).*sX .* A12;
                tauxy = tauxy + bn(m).*cX .* ...
                    ( (ah*sh).*cy - alpha*Y.*sy.*ch )/Dm ...
                              - bn(m).*cX .* ...
                              ( (ah*ch).*sy - alpha*Y.*cy.*sh )/Dp;
            end

            % strains (plane stress) -> integrate to u0,v0
            epsx = (sigx - nu*sigy)/E;
            epsy = (sigy - nu*sigx)/E;

            u0 = zeros(Ny,Nx);
            for j = 1:Ny
                u0(j,:) = cumtrapz(xv, epsx(j,:));
            end

            v0 = zeros(Ny,Nx);
            for i = 1:Nx
                col  = epsy(:,i);
                vtmp = cumtrapz(yv, col);
                v0(:,i) = vtmp - vtmp(iy0);  % enforce v0(x,0)=0
            end

            % shear compatibility correction via separated fit
            [~,Uy] = gradient(u0, dx, dy);   % Uy = du/dy
            [Vx,~] = gradient(v0, dx, dy);   % Vx = dv/dx
            R = Uy + Vx - tauxy./G;

            K     = mean(R(:));
            Fbase = mean(R,1) - K;          % function of x
            Gbase = mean(R,2).' - K;        % function of y

            f2 = -cumtrapz(xv, Fbase);  f2 = f2(:).';
            f1 = -cumtrapz(yv, Gbase.'); f1 = f1(:);
            f1 = f1 - f1(iy0);           % anchor f1(0)=0

            u = u0 + repmat(f1, 1, Nx);
            v = v0 + repmat(f2, Ny, 1);

            % clamp (x=l,y=0): zero translations + zero slope v_x
            u = u - u(iy0,ixL);
            v = v - v(iy0,ixL);
            Srot = (v(iy0,ixL) - v(iy0,ixL-1))/dx;
            u = u + Srot * (yv.' * ones(1,Nx));
            v = v - Srot * (ones(Ny,1) * (xv - l));
        end

        function [u,v,xv,yv,sigx,sigy,tauxy] = solve_plate_exp(obj)
            k = obj.k;  l = obj.l;  E = obj.E;  nu = obj.nu;  w0 = obj.w0;
            Nx = obj.Nx;Ny = obj.Ny;h = obj.h;
        
            G = E/(2*(1+nu));
            xv = linspace(0, l, Nx);  yv = linspace(-h, h, Ny);
            [X,Y] = meshgrid(xv,yv);
            dx = xv(2)-xv(1);   dy = yv(2)-yv(1);
        
            [~,iy0] = min(abs(yv));
            ixL = Nx;
        
            alpha = k/l;
            w_eff = -w0;
        
            s = sin(alpha*h);
            c = cos(alpha*h);
            den1 = (alpha*h + s*c);
            den2 = (alpha*h - s*c);
                
            % Closed-form constants (fast, stable away from resonance)
            A =  w_eff*(alpha*h*c + s) / (2*alpha^2*den1);
            B = -w_eff*c / (2*alpha*den2);
            C = -w_eff*(alpha*h*s - c) / (2*alpha^2*den2);
            D =  w_eff*s / (2*alpha*den1);

            % ---- f, f', f'' on the whole grid ----
            cy = cos(alpha*Y);   sy = sin(alpha*Y);
            f   = (A + B.*Y).*cy + (C + D.*Y).*sy;
            fp  = (B + alpha*(C + D.*Y)).*cy + (D - alpha*(A + B.*Y)).*sy;
            fpp = (alpha*(2*D - alpha*A) - alpha^2*B.*Y).*cy + ...
                  (-alpha*(2*B + alpha*C) - alpha^2*D.*Y).*sy;
        
            % ---- Stresses from Airy ----
            expax  = exp(alpha*X);
            sigx   = expax .* fpp;          % sigma_x = d2(phi)/dy2
            sigy   = alpha^2 * expax .* f;  % sigma_y = d2(phi)/dx2
            tauxy  = -alpha  * expax .* fp; % tau_xy  = -d2(phi)/(dx dy)
        
            % ---- Strains (plane stress) and displacement integration ----
            epsx = (sigx - nu*sigy)/E;
            epsy = (sigy - nu*sigx)/E;
        
            u0 = zeros(Ny,Nx);
            for j = 1:Ny
                u0(j,:) = cumtrapz(xv, epsx(j,:));
            end
        
            v0 = zeros(Ny,Nx);
            for i = 1:Nx
                col  = epsy(:,i);
                vtmp = cumtrapz(yv, col);
                v0(:,i) = vtmp - vtmp(iy0);  % enforce v0(x,0)=0
            end
        
            % ---- Shear compatibility correction via separated fit ----
            [~,Uy] = gradient(u0, dx, dy);   % Uy = du/dy
            [Vx,~] = gradient(v0, dx, dy);   % Vx = dv/dx
            R = Uy + Vx - tauxy./G;
        
            K     = mean(R(:));
            Fbase = mean(R,1) - K;          % function of x
            Gbase = mean(R,2).' - K;        % function of y
        
            f2 = -cumtrapz(xv, Fbase);  f2 = f2(:).';
            f1 = -cumtrapz(yv, Gbase.'); f1 = f1(:);
            f1 = f1 - f1(iy0);           % anchor f1(0)=0
        
            u = u0 + repmat(f1, 1, Nx);
            v = v0 + repmat(f2, Ny, 1);
        
            % ---- Clamp at (x=l, y=0): zero translations + zero slope v_x ----
            u = u - u(iy0,ixL);
            v = v - v(iy0,ixL);
            Srot = (v(iy0,ixL) - v(iy0,ixL-1))/dx;
            u = u + Srot * (yv.' * ones(1,Nx));
            v = v - Srot * (ones(Ny,1) * (xv - l));
        end

        function [u,v,xv,yv,sigx,sigy,tauxy] =...
                solve_plate_concentrated(obj, clampMode)
            % Concentrated vertical load P applied at the left end (x=0).
            % clampMode: "vx0"  -> enforce v_x(l,0)=0   (default)
            %            "uy0"  -> enforce u_y(l,0)=0
            if nargin < 2 || isempty(clampMode), clampMode = "vx0"; end
            % geometry & material
            l  = obj.l;      h  = obj.h;
            E  = obj.E;      nu = obj.nu;
            Nx = obj.Nx;     Ny = obj.Ny;
            P = obj.P;
        
            G = E/(2*(1+nu));   I = (2/3)*h^3; % plate paramters
        
            % grid
            xv = linspace(0,l,Nx);
            yv = linspace(-h,h,Ny);
            [X,Y] = meshgrid(xv,yv);
        
            % Stresses
            sigx  = (P/I) .* (X.*Y);
            sigy  = zeros(Ny,Nx);
            tauxy = (P/(2*I)) .* (h^2 - Y.^2);
        
            % Displacements via Hooke + shear separation + clamp constants
            switch string(clampMode)
                case "vx0"      % v_x(l,0)=0
                    u =  (P.*X.^2.*Y)/(2*E*I) ...
                       + (nu*P*Y.^3)/(6*E*I) - (P*Y.^3)/(6*G*I) ...
                       + ( (P*h^2)/(2*G*I) - (P*l^2)/(2*E*I) ) .* Y;                   % u1
                    v = -(nu*P*X.*Y.^2)/(2*E*I) ...
                       - (P*X.^3)/(6*E*I) + (P*l^2*X)/(2*E*I) - (P*l^3)/(3*E*I);       % v1
        
                case "uy0"      % u_y(l,0)=0
                    u =  (P.*X.^2.*Y)/(2*E*I) ...
                       + (nu*P*Y.^3)/(6*E*I) - (P*Y.^3)/(6*G*I) ...
                       - (P*l^2/(2*E*I)) .* Y;                                          % u2
                    v = -(nu*P*X.*Y.^2)/(2*E*I) ...
                       - (P*X.^3)/(6*E*I) + (P*l^2*X)/(2*E*I) - (P*l^3)/(3*E*I) ...
                       - (P*h^2)/(2*G*I) .* (l - X);                                    % v2
            end
        end

        function [u,v,xv,yv,sigx,sigy,tauxy] = solve_plate_k0(obj)
            % geometry & material
            l  = obj.l;      h  = obj.h;
            E  = obj.E;      nu = obj.nu;
            Nx = obj.Nx;     Ny = obj.Ny;
            w0 = obj.w0;     % uniform (k=0) load
        
            % elastic constants
            G = E/(2*(1+nu));
            I = (2/3)*h^3;                    % unit width
        
            % grid
            xv = linspace(0,l,Nx);
            yv = linspace(-h,h,Ny);
            [X,Y] = meshgrid(xv,yv);
            [~,iy0] = min(abs(yv));           % midline row index
        
            % ---- Stresses for k=0 (Eq. 32) over the full plate ----
            sigx  = (w0/(2*I)) .* ( (l - X).*X.*Y + (2/3)*Y.^3 - (2/5)*h^2.*Y );
            sigy  = -(w0/(2*I)) .* ( (1/3)*Y.^3 - h^2.*Y + (2/3)*h^3 );
            tauxy = -(w0/(2*I)) .* ( (h^2 - Y.^2) .* (X - 0.5*l) );
        
            % ---- Midline displacement (Eq. 34) + P* superposition ----
            % P* chosen to enforce v(0,0)=0 while preserving weak clamp
            Pstar =  (3/2) * h^2 * (1+nu) * w0 / (l);
        
            u_mid = -(nu.*w0.*(l - xv))./(2.*E);
            v_mid = -(w0.*xv.*(l - xv).^2.*...
                (10.*l.*xv + 30.*h.^2.*nu + 48.*h.^2 - 25.*l.^2))./...
                (160*E*h^3*l);
        
            % ---- Return u,v only on the midline (other rows = NaN) ----
            u = NaN(Ny, Nx);   v = NaN(Ny, Nx);
            u(iy0,:) = u_mid;
            v(iy0,:) = v_mid;
        end

        function [u,v,xv,yv] = solve_beam_k0(obj)
            % geometry & material
            l  = obj.l;      h  = obj.h;
            E  = obj.E;      nu = obj.nu;
            Nx = obj.Nx;     Ny = obj.Ny;
            w0 = obj.w0;     % uniform (k=0) load
        
            % elastic constants
            G = E/(2*(1+nu));
            I = (2/3)*h^3;                    % unit width
        
            % grid
            xv = linspace(0,l,Nx);
            yv = linspace(-h,h,Ny);
            [X,Y] = meshgrid(xv,yv);
            [~,iy0] = min(abs(yv));           % midline row index
        
            % ---- Midline displacement (Eq. 34) + P* superposition ----
            u_mid = 0;
            v_mid = (xv.*(l-xv).^2.*(l+2.*xv))/(48*E*I)*w0;
        
            % ---- Return u,v only on the midline (other rows = NaN) ----
            u = NaN(Ny, Nx);   v = NaN(Ny, Nx);
            u(iy0,:) = u_mid;
            v(iy0,:) = v_mid;
        end

        function [u,v,xv,yv,sigx,sigy,tauxy,Pstar] =...
                solve_superposed_zeroV(obj)
       
            % Exponential-load solution
            [u_w, v_w, xv, yv, sx_w, sy_w, txy_w] = obj.solve_plate_exp();
        
            % Concentrated-load solution at unit P
            [u_P1, v_P1, ~, ~, sx_P1, sy_P1, txy_P1] = ...
                obj.solve_plate_concentrated('vx0');
        
            % x, y indecies
            [~, ix0] = min(abs(xv));    [~, iy0] = min(abs(yv));
            
            % solve for P so v_total(x0,y0)=0
            Pstar = - v_w(iy0, ix0) / v_P1(iy0, ix0);
        
            % Superpose fields
            u     = u_w   + Pstar * u_P1;
            v     = v_w   + Pstar * v_P1;
            sigx  = sx_w  + Pstar * sx_P1;
            sigy  = sy_w  + Pstar * sy_P1;
            tauxy = txy_w + Pstar * txy_P1;
        end
    end
end